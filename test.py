from glob import glob
import os
import sys
import time
from collections import OrderedDict
import imageio

import numpy as np
from sklearn.model_selection import train_test_split
from skimage.io import imread, imsave 
from hausdorff import hausdorff_distance

import torch
import torchvision
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms.functional as tf
import torch.utils.data as data
from torch.cuda import amp
import torch.backends.cudnn as cudnn

from tqdm import tqdm
import pickle
import pandas as pd

from metrics import *
from utils import *
from model import *
from dataset import *

def main():
    BATCH_SIZE = 32
    DEVICE = 'cuda' if torch.cuda.is_available() else 'cpu'
    TEST_IMG_DIR = glob(r'D:\\AI MSc Large Modules\\Masters_Project\\CODE\\Deep-Inter-Active-Refinement-Network-for-Medical-Image-Segmentation\\data\\test\\img\\*')
    TEST_LABEL_DIR = glob(r'D:\\AI MSc Large Modules\\Masters_Project\\CODE\\Deep-Inter-Active-Refinement-Network-for-Medical-Image-Segmentation\\data\\test\\label\\*')

    test_img_paths =  TEST_IMG_DIR
    test_mask_paths = TEST_LABEL_DIR
    print("test_num:%s"%str(len(test_img_paths)))

    # model, loss criteria, optimiser
    model = UNet2D(in_channels=4, out_channels=3).to(DEVICE) 
    print("=> Creating 2D UNET Model")
    
    model.load_state_dict(torch.load('models/2DUNET.pth'))
    model.eval()

    test_dataset = Dataset(test_img_paths, test_mask_paths)
    test_loader = torch.utils.data.DataLoader(
        test_dataset,
        batch_size=BATCH_SIZE,
        shuffle=False,
        pin_memory=True,
        drop_last=False)

    """
    obtain and save the label map generated by the model 
    """
    with torch.no_grad():
        for batch_idx, (data, labels) in tqdm(enumerate(test_loader), total=len(test_loader)):
            data = data.to(DEVICE) 
            
            preds = model(data)
            preds = torch.sigmoid(preds).data.cpu().numpy()
            
            img_paths = test_img_paths[BATCH_SIZE*batch_idx:BATCH_SIZE*(batch_idx+1)]

            for i in range(preds.shape[0]):
                npName = os.path.basename(img_paths[i])
                overNum = npName.find(".npy")
                rgbName = npName[0:overNum]
                rgbName = rgbName  + ".png"
                rgbPic = np.zeros([160, 160, 3], dtype=np.uint8)
                for idx in range(preds.shape[2]):
                    for idy in range(preds.shape[3]):
                        if preds[i,0,idx,idy] > 0.5:
                            rgbPic[idx, idy, 0] = 0
                            rgbPic[idx, idy, 1] = 128
                            rgbPic[idx, idy, 2] = 0
                        if preds[i,1,idx,idy] > 0.5:
                            rgbPic[idx, idy, 0] = 255
                            rgbPic[idx, idy, 1] = 0
                            rgbPic[idx, idy, 2] = 0
                        if preds[i,2,idx,idy] > 0.5:
                            rgbPic[idx, idy, 0] = 255
                            rgbPic[idx, idy, 1] = 255
                            rgbPic[idx, idy, 2] = 0
                imsave('base_test_results/output/' + rgbName, rgbPic, check_contrast=False)

    torch.cuda.empty_cache()

    """
    convert the GT numpy format in the test set to a picture format and save 
    """
    print("Saving GT, numpy to picture")
    test_gt_path = 'base_test_results/output/' + 'GT/'
    if not os.path.exists(test_gt_path):
        os.mkdir(test_gt_path)
    for idx in tqdm(range(len(test_mask_paths))):
        mask_path = test_mask_paths[idx]
        name = os.path.basename(mask_path)
        overNum = name.find(".npy")
        name = name[0:overNum]
        rgbName = name + ".png"

        npmask = np.load(mask_path)

        GtColor = np.zeros([npmask.shape[0],npmask.shape[1],3], dtype=np.uint8)
        for idx in range(npmask.shape[0]):
            for idy in range(npmask.shape[1]):
                #(NET, non-enhancing tumor)(label 1) red
                if npmask[idx, idy] == 1:
                    GtColor[idx, idy, 0] = 255
                    GtColor[idx, idy, 1] = 0
                    GtColor[idx, idy, 2] = 0
                #(ED, peritumoral edema) (label 2) green
                elif npmask[idx, idy] == 2:
                    GtColor[idx, idy, 0] = 0
                    GtColor[idx, idy, 1] = 128
                    GtColor[idx, idy, 2] = 0
                #(ET, enhancing tumor)(label 4) yellow
                elif npmask[idx, idy] == 4:
                    GtColor[idx, idy, 0] = 255
                    GtColor[idx, idy, 1] = 255
                    GtColor[idx, idy, 2] = 0

        imageio.imwrite(test_gt_path + rgbName, GtColor)

    """
    calculate metrics: Dice, Sensitivity, PPV, Hausdorff
    """
    wt_dices = []
    tc_dices = []
    et_dices = []
    wt_sensitivities = []
    tc_sensitivities = []
    et_sensitivities = []
    wt_ppvs = []
    tc_ppvs = []
    et_ppvs = []
    wt_Hausdorf = []
    tc_Hausdorf = []
    et_Hausdorf = []

    wtMaskList = []
    tcMaskList = []
    etMaskList = []
    wtPbList = []
    tcPbList = []
    etPbList = []

    maskPath = glob("base_test_results/output/" + "GT\*.png")
    pbPath = glob("base_test_results/output/" + "*.png")

    for myi in tqdm(range(len(maskPath))):
        mask = imread(maskPath[myi])
        pb = imread(pbPath[myi])

        wtmaskregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)
        wtpbregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)

        tcmaskregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)
        tcpbregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)

        etmaskregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)
        etpbregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)

        for idx in range(mask.shape[0]):
            for idy in range(mask.shape[1]):
                # As long as any channel of this pixel has a value, it means that this pixel does not belong to the foreground, that is, it belongs to the WT area 
                if mask[idx, idy, :].any() != 0:
                    wtmaskregion[idx, idy] = 1
                if pb[idx, idy, :].any() != 0:
                    wtpbregion[idx, idy] = 1
                # As long as the first channel is 255, it can be judged to be the TC area, because the first channel of red and yellow are both 255, which is different from green 
                if mask[idx, idy, 0] == 255:
                    tcmaskregion[idx, idy] = 1
                if pb[idx, idy, 0] == 255:
                    tcpbregion[idx, idy] = 1
                # As long as the second channel is 128, it can be judged to be the ET area 
                if mask[idx, idy, 1] == 128:
                    etmaskregion[idx, idy] = 1
                if pb[idx, idy, 1] == 128:
                    etpbregion[idx, idy] = 1
        #Start calculating WT
        dice = dice_coef(wtpbregion,wtmaskregion)
        wt_dices.append(dice)
        ppv_n = ppv(wtpbregion, wtmaskregion)
        wt_ppvs.append(ppv_n)
        Hausdorff = hausdorff_distance(wtmaskregion, wtpbregion)
        wt_Hausdorf.append(Hausdorff)
        sensitivity_n = sensitivity(wtpbregion, wtmaskregion)
        wt_sensitivities.append(sensitivity_n)

        # Start calculating TC
        dice = dice_coef(tcpbregion, tcmaskregion)
        tc_dices.append(dice)
        ppv_n = ppv(tcpbregion, tcmaskregion)
        tc_ppvs.append(ppv_n)
        Hausdorff = hausdorff_distance(tcmaskregion, tcpbregion)
        tc_Hausdorf.append(Hausdorff)
        sensitivity_n = sensitivity(tcpbregion, tcmaskregion)
        tc_sensitivities.append(sensitivity_n)

        # Start calculating ET
        dice = dice_coef(etpbregion, etmaskregion)
        et_dices.append(dice)
        ppv_n = ppv(etpbregion, etmaskregion)
        et_ppvs.append(ppv_n)
        Hausdorff = hausdorff_distance(etmaskregion, etpbregion)
        et_Hausdorf.append(Hausdorff)
        sensitivity_n = sensitivity(etpbregion, etmaskregion)
        et_sensitivities.append(sensitivity_n)

    print('WT Dice: %.4f' % np.mean(wt_dices))
    print('TC Dice: %.4f' % np.mean(tc_dices))
    print('ET Dice: %.4f' % np.mean(et_dices))
    print("=============")
    print('WT PPV: %.4f' % np.mean(wt_ppvs))
    print('TC PPV: %.4f' % np.mean(tc_ppvs))
    print('ET PPV: %.4f' % np.mean(et_ppvs))
    print("=============")
    print('WT sensitivity: %.4f' % np.mean(wt_sensitivities))
    print('TC sensitivity: %.4f' % np.mean(tc_sensitivities))
    print('ET sensitivity: %.4f' % np.mean(et_sensitivities))
    print("=============")
    print('WT Hausdorff: %.4f' % np.mean(wt_Hausdorf))
    print('TC Hausdorff: %.4f' % np.mean(tc_Hausdorf))
    print('ET Hausdorff: %.4f' % np.mean(et_Hausdorf))
    print("=============")

    
if __name__ == '__main__':
    main()
